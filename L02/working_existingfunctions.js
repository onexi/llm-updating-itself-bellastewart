import express from 'express';
import bodyParser from 'body-parser';
import { OpenAI } from 'openai';
import path from 'path';
import { fileURLToPath } from 'url';
import fs from 'fs';
import dotenv from 'dotenv';

// Load environment variables
dotenv.config();

// Initialize Express server
const app = express();
app.use(bodyParser.json());

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Serve static files (your index.html, etc.)
app.use(express.static(path.resolve(__dirname, './public')));

// OpenAI API configuration
const openai = new OpenAI({
  apiKey: process.env.OPENAI_API_KEY,
});

// 1️⃣ Load existing tools (functions) from /functions/
async function getTools() {
  const folderPath = path.resolve(__dirname, './functions');
  if (!fs.existsSync(folderPath)) {
    fs.mkdirSync(folderPath);
  }

  const files = fs.readdirSync(folderPath);
  const tools = {};

  for (const file of files) {
    if (file.endsWith('.js')) {
      const moduleName = file.slice(0, -3);
      const modulePath = path.resolve(folderPath, file);

      try {
        // Dynamically import the function module
        const { details, execute } = await import(`file://${modulePath}`);
        tools[moduleName] = { details, execute };
      } catch (error) {
        console.error(`Error loading tool ${moduleName}:`, error);
      }
    }
  }
  return tools;
}

// 2️⃣ Find the best matching tool using GPT
async function findBestMatchingTool(userPrompt, tools) {
  if (Object.keys(tools).length === 0) return null;

  const toolInfo = Object.entries(tools).map(([name, tool]) => {
    return `${name}: ${tool.details.description}`;
  });

  const query = `
  I have these tools:
  ${toolInfo.join('\n')}
  
  A user wants: "${userPrompt}"
  
  Which tool name best matches their request? If none match, return "none". 
  Return exactly one line with the tool name or "none".
  `;

  try {
    const response = await openai.chat.completions.create({
      model: 'gpt-4o',
      messages: [
        { role: 'system', content: 'You are a helpful assistant that picks the best matching tool name from the list.' },
        { role: 'user', content: query }
      ]
    });

    const bestMatch = response?.choices?.[0]?.message?.content?.trim() || 'none';
    if (bestMatch === 'none' || !Object.keys(tools).includes(bestMatch)) {
      return null;
    }
    return bestMatch;
  } catch (error) {
    console.error('Failed to match tool:', error);
    return null;
  }
}

// 3️⃣ Generate a new tool using GPT and save it in /functions/
async function generateTool(toolName, toolDescription) {
  try {
    const response = await openai.chat.completions.create({
      model: 'gpt-4o',
      messages: [
        { role: 'system', content: 'You are a skilled JavaScript developer. Generate a function based on user input.' },
        {
          role: 'user',
          content: `Write a JavaScript function called "execute" to ${toolDescription}. 
          The function should be formatted as follows:
          
          const execute = async (...) => { ... };

          const details = {
            type: "function",
            function: {
                name: "${toolName}",
                parameters: { ... },
                required: [ ... ]
            },
            description: "${toolDescription}"
          };

          Export both as a module.`
        }
      ]
    });

    const generatedCode = response?.choices?.[0]?.message?.content;
    if (!generatedCode) {
      throw new Error('No code generated by GPT.');
    }

    if (
      !generatedCode.includes('const execute') ||
      !generatedCode.includes('export { execute, details }')
    ) {
      throw new Error('Generated function is not in the expected format.');
    }

    const fileName = `${toolName}.js`;
    const toolPath = path.resolve(__dirname, './functions', fileName);
    fs.writeFileSync(toolPath, generatedCode);

    console.log(`✅ Tool ${toolName} generated and saved at ${toolPath}.`);
    return { success: true, toolName };
  } catch (error) {
    console.error('Failed to generate tool:', error);
    return { success: false, error: error.message };
  }
}

// NEW: Helper function to extract parameters using GPT reasoning over the user input
async function extractParamsFromUserPrompt(userPrompt, toolDetails) {
  // Use the correct parameter schema and required keys from the parameters object.
  const parameterInfo = JSON.stringify(toolDetails.function.parameters);
  const requiredParams = toolDetails.function.parameters.required.join(', ');
  const promptMessage = `
You are a programming assistant. A user has provided the following request: "${userPrompt}".
There is a function called "${toolDetails.function.name}" which expects parameters as described here: ${parameterInfo}.
The required parameters, in order, are: ${requiredParams}.
Extract the parameters from the user request and return a JSON array of argument values in the order specified.
If a parameter is expected to be a number, return it as a number; if it's expected to be a string, return it as a string.
For example, if the function expects a name and the user said "greet Bella", the response should be: ["Bella"].
If the function expects two numbers and the user said "addnumber 5 and 9", the response should be: [5, 9].
Output only a JSON array with no additional text.
  `;

  try {
    const response = await openai.chat.completions.create({
      model: 'gpt-4o',
      messages: [
        { role: 'system', content: 'You are a helpful assistant that extracts function parameters from a user request.' },
        { role: 'user', content: promptMessage }
      ]
    });
    const content = response?.choices?.[0]?.message?.content?.trim();
    if (!content) {
      console.error("No content received from GPT parameter extraction.");
      return [];
    }
    try {
      const params = JSON.parse(content);
      return params;
    } catch (err) {
      console.error("JSON parsing failed in parameter extraction:", err, "with content:", content);
      return [];
    }
  } catch (error) {
    console.error('Parameter extraction failed:', error);
    return [];
  }
}

// NEW: Helper function to finalize the parameters by reasoning how they should be used when executing the tool
async function finalizeParams(extractedParams, toolDetails, userPrompt) {
  const parameterInfo = JSON.stringify(toolDetails.function.parameters);
  const requiredParams = toolDetails.function.parameters.required.join(', ');
  const prompt = `
You are an assistant who finalizes parameter mapping for a function call.
The function "${toolDetails.function.name}" expects parameters as described below:
Parameters: ${parameterInfo}
Required order: ${requiredParams}

The extracted parameters from the user's request "${userPrompt}" are: ${JSON.stringify(extractedParams)}.
Please verify and finalize the parameters that should be used when calling the function.
For example, if the function is greetUser and expects a name, ensure that ["Bella"] is used as the name.
If the function is addNumbers and expects two numbers, ensure that the final result is a JSON array like [5, 9].
Return only a JSON array with the finalized parameter values.
  `;

  try {
    const response = await openai.chat.completions.create({
      model: 'gpt-4o',
      messages: [
        { role: 'system', content: 'You are a helpful assistant that finalizes parameter mapping.' },
        { role: 'user', content: prompt }
      ]
    });
    const content = response?.choices?.[0]?.message?.content?.trim();
    if (!content) {
      console.error('No content received from GPT in finalizeParams.');
      return extractedParams;
    }
    try {
      const finalParams = JSON.parse(content);
      return finalParams;
    } catch (err) {
      console.error("JSON parsing failed in finalizeParams:", err, "with content:", content);
      return extractedParams;
    }
  } catch (error) {
    console.error('finalizeParams call failed:', error);
    return extractedParams;
  }
}

// 4️⃣ Main route: process user requests, pick or generate a tool, then execute
app.post('/process-request', async (req, res) => {
  const { userPrompt } = req.body;
  if (!userPrompt) {
    return res.status(400).json({ error: 'Missing user request.' });
  }

  // Load existing tools
  let tools = await getTools();

  // 4a. Ask GPT which tool (by name) best matches this user prompt
  let matchedToolName = await findBestMatchingTool(userPrompt, tools);

  // 4b. If no match, generate a new tool
  let selectedTool;
  if (!matchedToolName) {
    console.log(`No matching tool found for: "${userPrompt}". Generating new tool...`);
    const newToolName = `generatedTool${Date.now()}`;
    const result = await generateTool(newToolName, userPrompt);
    if (!result.success) {
      return res.status(500).json({ error: 'Tool generation failed', details: result.error });
    }
    tools = await getTools();
    matchedToolName = result.toolName;
  }

  // 4c. Now we should have a matched or newly generated tool
  selectedTool = tools[matchedToolName]?.execute;
  if (!selectedTool) {
    return res.status(500).json({ error: 'Tool not found after generation.' });
  }

  // 4d. Extract parameters using GPT reasoning over the user input
  let extractedParams = await extractParamsFromUserPrompt(userPrompt, tools[matchedToolName].details);
  if (!Array.isArray(extractedParams)) {
    extractedParams = [extractedParams];
  }
  
  // 4d2. Finalize the parameters using a new GPT assistant that reasons how they should be used
  let finalParams = await finalizeParams(extractedParams, tools[matchedToolName].details, userPrompt);
  if (!Array.isArray(finalParams)) {
    finalParams = [finalParams];
  }

  // 4e. Execute the tool with the finalized parameters and ensure a valid JSON response
  try {
    const result = await selectedTool(...finalParams);
    console.log(`Executed tool "${matchedToolName}" with result:`, result);
    const responseBody = (result !== undefined && result !== null && result !== '')
      ? result
      : { message: 'No result returned by tool.' };
    return res.json(responseBody);
  } catch (error) {
    console.error('Tool execution failed:', error);
    return res.status(500).json({ error: 'Tool execution failed', details: error.message });
  }
});

// Start the server
const PORT = 3000;
app.listen(PORT, () => {
  console.log(`Server running at http://localhost:${PORT}`);
});
