import express from 'express';
import bodyParser from 'body-parser';
import { OpenAI } from 'openai';
import path from 'path';
import { fileURLToPath } from 'url';
import fs from 'fs';
import dotenv from 'dotenv';

// Load environment variables
dotenv.config();

// Initialize Express server
const app = express();
app.use(bodyParser.json());

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Serve static files (your index.html, etc.)
app.use(express.static(path.resolve(__dirname, './public')));

// OpenAI API configuration
const openai = new OpenAI({
  apiKey: process.env.OPENAI_API_KEY,
});

// 1️⃣ Load existing tools (functions) from /functions/
async function getTools() {
  const folderPath = path.resolve(__dirname, './functions');
  if (!fs.existsSync(folderPath)) {
    fs.mkdirSync(folderPath);
  }
  const files = fs.readdirSync(folderPath);
  const tools = {};
  for (const file of files) {
    if (file.endsWith('.js')) {
      const moduleName = file.slice(0, -3);
      const modulePath = path.resolve(folderPath, file);
      try {
        const { details, execute } = await import(`file://${modulePath}`);
        tools[moduleName] = { details, execute };
      } catch (error) {
        console.error(`Error loading tool ${moduleName}:`, error);
      }
    }
  }
  return tools;
}

// 2️⃣ Find the best matching tool using GPT, considering that if none exists it should be generated.
async function findBestMatchingTool(userPrompt, tools) {
  if (Object.keys(tools).length === 0) return null;
  const toolInfo = Object.entries(tools).map(([name, tool]) => {
    return `${name}: ${tool.details.description}`;
  });
  const query = `
I have these tools:
${toolInfo.join('\n')}

A user wants: "${userPrompt}"

Based on the user's intent (for example, if the user said "multiply 2 and 5", it implies a multiplication function with two numeric parameters), which tool name best matches their request? If none match, return "none".
Return exactly one line with the tool name or "none".
  `;
  try {
    const response = await openai.chat.completions.create({
      model: 'gpt-4o',
      messages: [
        { role: 'system', content: 'You are a helpful assistant that picks the best matching tool name from the list. Consider that if the function does not exist, a new one should be generated based on the user intent.' },
        { role: 'user', content: query }
      ]
    });
    const bestMatch = response?.choices?.[0]?.message?.content?.trim() || 'none';
    if (bestMatch === 'none' || !Object.keys(tools).includes(bestMatch)) {
      return null;
    }
    return bestMatch;
  } catch (error) {
    console.error('Failed to match tool:', error);
    return null;
  }
}

// 3️⃣ Generate a new tool using GPT and save it in /functions/.
// The instructions now emphasize reasoning about the user request.
async function generateTool(toolName, toolDescription) {
  const instructions = `
You are a skilled JavaScript developer. A user request has been received: "${toolDescription}".
Generate a generic JavaScript function that can fulfill the request. For instance, if the user said "multiply 2 and 5", the function should not hard-code the values but be generic, accepting two numeric parameters for multiplication.
The function should be named "execute" and exported along with a "details" object.
The "details" object must include:
  - type: "function"
  - function: an object with:
      - name: set to "${toolName}"
      - parameters: an object that follows the JSON Schema standard with "type": "object", "properties" for each parameter, and a "required" array listing the required parameter names.
  - description: should be the same as "${toolDescription}".
Format your code exactly as follows:

const execute = async (/* your parameters here */) => {
    // function implementation
};

const details = {
    type: "function",
    function: {
        name: "${toolName}",
        parameters: {
            type: "object",
            properties: {
                // define properties with types and descriptions
            },
            required: [ /* list required parameter names */ ]
        }
    },
    description: "${toolDescription}"
};

Export { execute, details };

Ensure your code is valid JavaScript.
Return only the code with no additional text.
  `;
  try {
    const response = await openai.chat.completions.create({
      model: 'gpt-4o',
      messages: [
        { role: 'system', content: 'You are a skilled JavaScript developer.' },
        { role: 'user', content: instructions }
      ]
    });
    let generatedCode = response?.choices?.[0]?.message?.content;
    if (!generatedCode) {
      throw new Error('No code generated by GPT.');
    }
    // Remove markdown code fences if present.
    generatedCode = generatedCode.trim();
    if (generatedCode.startsWith('```')) {
      generatedCode = generatedCode.replace(/^```(?:javascript)?\s*/, '').replace(/\s*```$/, '');
    }
    if (
      !generatedCode.includes('const execute') ||
      !generatedCode.includes('export { execute, details }')
    ) {
      throw new Error('Generated function is not in the expected format.');
    }
    const fileName = `${toolName}.js`;
    const toolPath = path.resolve(__dirname, './functions', fileName);
    fs.writeFileSync(toolPath, generatedCode);
    console.log(`✅ Tool ${toolName} generated and saved at ${toolPath}.`);
    return { success: true, toolName };
  } catch (error) {
    console.error('Failed to generate tool:', error);
    return { success: false, error: error.message };
  }
}

// 4️⃣ Helper function to extract parameters using GPT reasoning over the user input.
// The prompt now stresses that the assistant should deduce the parameters from the user's intent.
async function extractParamsFromUserPrompt(userPrompt, toolDetails) {
  // If the tool's parameter schema is empty, fallback to extracting numbers.
  if (
    !toolDetails.function.parameters ||
    !toolDetails.function.parameters.required ||
    toolDetails.function.parameters.required.length === 0
  ) {
    const numbers = userPrompt.match(/\d+(\.\d+)?/g);
    if (numbers) return numbers.map(Number);
    return [];
  }
  const parameterInfo = JSON.stringify(toolDetails.function.parameters);
  const requiredParams = toolDetails.function.parameters.required.join(', ');
  const promptMessage = `
You are a programming assistant. A user has provided the following request: "${userPrompt}".
There is a function called "${toolDetails.function.name}" which expects parameters as described below:
${parameterInfo}
The required parameters, in order, are: ${requiredParams}. Based on the intent of the user's request (for example, if the request is "multiply 2 and 5" or "add 2 and 3 and 4", extract all the numbers mentioned), identify and extract each parameter in sequence. For each parameter, if a number is expected, return it as a number; if a string is expected, return it as a string, and so on. If multiple numbers are expected, return it as a series of numbers. If multiple strings are expected, return it as a series of strings.
Return only a JSON array of argument values in the specified order with no additional text.
  `;
  try {
    const response = await openai.chat.completions.create({
      model: 'gpt-4o',
      messages: [
        { role: 'system', content: 'You are a helpful assistant that extracts function parameters from a user request.' },
        { role: 'user', content: promptMessage }
      ]
    });
    const content = response?.choices?.[0]?.message?.content?.trim();
    if (!content) {
      console.error("No content received from GPT parameter extraction.");
      return [];
    }
    try {
      const params = JSON.parse(content);
      return params;
    } catch (err) {
      console.error("JSON parsing failed in parameter extraction:", err, "with content:", content);
      return [];
    }
  } catch (error) {
    console.error('Parameter extraction failed:', error);
    return [];
  }
}

// 5️⃣ Helper function to finalize the parameters by reasoning how they should be used when executing the tool.
// The prompt now instructs the assistant to verify and map the extracted parameters based on the intended operation.
async function finalizeParams(extractedParams, toolDetails, userPrompt) {
  // If the schema is empty, assume the extracted parameters are final.
  if (
    !toolDetails.function.parameters ||
    !toolDetails.function.parameters.required ||
    toolDetails.function.parameters.required.length === 0
  ) {
    return extractedParams;
  }
  const parameterInfo = JSON.stringify(toolDetails.function.parameters);
  const requiredParams = toolDetails.function.parameters.required.join(', ');
  const prompt = `
You are an assistant who finalizes parameter mapping for a function call.
The function "${toolDetails.function.name}" expects parameters as described below:
Parameters: ${parameterInfo}
Required order: ${requiredParams}

The extracted parameters from the user's request "${userPrompt}" are: ${JSON.stringify(extractedParams)}.
Based on the user intent, verify and finalize the parameters that should be used when calling the function.
Return only a JSON array with the finalized parameter values.
  `;
  try {
    const response = await openai.chat.completions.create({
      model: 'gpt-4o',
      messages: [
        { role: 'system', content: 'You are a helpful assistant that finalizes parameter mapping.' },
        { role: 'user', content: prompt }
      ]
    });
    const content = response?.choices?.[0]?.message?.content?.trim();
    if (!content) {
      console.error('No content received from GPT in finalizeParams.');
      return extractedParams;
    }
    try {
      const finalParams = JSON.parse(content);
      return finalParams;
    } catch (err) {
      console.error("JSON parsing failed in finalizeParams:", err, "with content:", content);
      return extractedParams;
    }
  } catch (error) {
    console.error('finalizeParams call failed:', error);
    return extractedParams;
  }
}

// 6️⃣ Main route: process user requests, pick or generate a tool, then execute.
app.post('/process-request', async (req, res) => {
  const { userPrompt } = req.body;
  if (!userPrompt) {
    return res.status(400).json({ error: 'Missing user request.' });
  }
  // Load existing tools.
  let tools = await getTools();
  // 6a. Ask GPT which tool (by name) best matches this user prompt.
  let matchedToolName = await findBestMatchingTool(userPrompt, tools);
  let currentToolDetails;
  // 6b. If no match, generate a new tool using GPT.
  if (!matchedToolName) {
    console.log(`No matching tool found for: "${userPrompt}". Generating new tool...`);
    const newToolName = `generatedTool${Date.now()}`;
    const result = await generateTool(newToolName, userPrompt);
    if (!result.success) {
      return res.status(500).json({ error: 'Tool generation failed', details: result.error });
    }
    tools = await getTools();
    matchedToolName = result.toolName;
  }
  // 6c. Retrieve the tool's execution function and details.
  const selectedTool = tools[matchedToolName]?.execute;
  currentToolDetails = tools[matchedToolName]?.details;
  if (!selectedTool || !currentToolDetails) {
    return res.status(500).json({ error: 'Tool not found after generation.' });
  }
  // 6d. Extract parameters using GPT reasoning over the user input using the current tool's details.
  let extractedParams = await extractParamsFromUserPrompt(userPrompt, currentToolDetails);
  if (!Array.isArray(extractedParams)) {
    extractedParams = [extractedParams];
  }
  // 6e. Finalize the parameters using a GPT assistant that reasons how they should be used.
  let finalParams = await finalizeParams(extractedParams, currentToolDetails, userPrompt);
  if (!Array.isArray(finalParams)) {
    finalParams = [finalParams];
  }
  // 6f. Execute the tool with the finalized parameters and ensure a valid JSON response.
  try {
    const result = await selectedTool(...finalParams);
    console.log(`Executed tool "${matchedToolName}" with result:`, result);
    const responseBody = (result !== undefined && result !== null && result !== '')
      ? result
      : { message: 'No result returned by tool.' };
    return res.json(responseBody);
  } catch (error) {
    console.error('Tool execution failed:', error);
    return res.status(500).json({ error: 'Tool execution failed', details: error.message });
  }
});

const PORT = 3000;
app.listen(PORT, () => {
  console.log(`Server running at http://localhost:${PORT}`);
});
